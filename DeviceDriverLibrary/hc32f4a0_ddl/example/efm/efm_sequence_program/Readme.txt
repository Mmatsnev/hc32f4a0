================================================================================
                                样例使用说明
================================================================================
版本历史
日期        版本    负责人     IAR     MDK     GCC     描述
2020-06-12  1.0     Heqb     7.70    5.16    8.3.1   First version
================================================================================
平台说明
================================================================================
GCC工程，由Eclipse IDE外挂GNU-ARM Toolchain，再结合pyOCD GDB Server实现工程的编译、
链接和调试。在用Eclipse导入工程后，请将xxxx_PyOCDDebug中pyocd-gdbserver和SVD文件
设置为正确的路径；请将xxxx_PyOCDDownload中pyocd设置为正确的路径。注意，这些路径不
能包含非英文字符。

================================================================================
功能描述
================================================================================
本样例为flash连续编程，flash全擦除。程序在RAM里面执行，同时也实现了BGO功能
（flash编程、擦除期间总线处于释放状态）。

================================================================================
测试环境
================================================================================
测试用板:
---------------------
EV_F4A0_LQ176_V10

辅助工具:
---------------------
无

辅助软件:
---------------------
无

================================================================================
使用步骤
================================================================================
1）打开工程，按照说明配置工程，重新编译；
2）启动IDE的下载和调试功能；
3）186行，188行，190行，192行，194行打上断点，可分别观察到flash0全擦除->flash0连续编程->
flash1全擦除->flash1连续编程->flash0和1全擦除等操作。

说明：
此样例编程地址需要和执行程序分属不同FLASH块或者程序在FLASH以外区域运行，即代码若
存放在flash块0中，连续编程和全擦除就需要放在flash块1中。

如果用户需要对整个flash进行全擦除或者连续编程，则需要将程序放在RAM中执行。使用
步骤如下：
1）打开工程，options->Linker->config，更改linker configuration file，选择
   HC32F4A0_RAM.icf；
2）options->Debugger->Download，取消勾选“use flash loader(s)”；
3）重新编译；
4）启动IDE的下载和调试功能；
5）在main函数中186,188,190,192,194行打上断点；
7）运行程序，在memory窗口可分别观察到flash0全擦除->flash0连续编程->flash1全擦除
->flash1连续编程->flash0和1全擦除。

步骤1）2）适用于IAR工程，KEIL工程参考设置
https://blog.csdn.net/wjs1033/article/details/51745494

================================================================================
注意
================================================================================
在bus_hold时，进行编程和擦除请勿单步调试，单步调试有可能使芯片发生未知错误

================================================================================
